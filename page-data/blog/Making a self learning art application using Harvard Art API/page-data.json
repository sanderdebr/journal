{"componentChunkName":"component---src-templates-blog-js","path":"/blog/Making a self learning art application using Harvard Art API","result":{"data":{"contentfulBlog":{"title":"Making a self learning art application using Harvard Art API","id":"dbbaa0a4-45f8-5276-baae-71360b2aca88","slug":"Making a self learning art application using Harvard Art API","content":{"childMarkdownRemark":{"html":"<p>Tutorial: self learning art application using Harvard Art API</p>\n<p>Today I will show you how to create a web application that teaches itself how to recommend the best art from the Harvard Art Museum to its users. We will use Adobe XD, HTML/CSS, vanilla Javascript and webpack. With an API connection we will retrieve the art.</p>\n<p>What you’ll learn in this tutorial\nHigh fidelity prototyping\nResponsive HTML5/CSS3 layout\nCSS BEM naming\nCSS Flexbox\nCSS Grid\nCSS button animation\nWebpack config\nVanilla JS ES6\nSetting up a backend server with Express\nSetting up a private API to connect backend with frontend\nSetting up a 3rd party API with Harvard art API\nDeploying front- and backend to Heroku </p>\n<ol>\n<li>Creating the design</li>\n</ol>\n<p>For the design, I like to keep things simple and clean. If you are new to design, try to check out dribbble.com and search for ‘art’ or gallery and get inspiration from here. I’m using Adobe XD, which you can download for free from <a href=\"https://www.adobe.com/products/xd.html\">https://www.adobe.com/products/xd.html</a></p>\n<p>If you prefer an online solution, you can use <a href=\"https://www.figma.com/\">https://www.figma.com/</a> - which is also free and works similar.</p>\n<p>For the app we basically only need two pages: 1) new user page where he/she selects here art preferences, and 2) an overview page with all art recommendations. It’s important to do some reaearch beforehand</p>\n<p>1.1 Creating the mockup</p>\n<p>To combine the 2 main functions from the app, we can place them on one page. So we will have the controls/settings on the left panel, and in the center we will see our art. Make sure you do not use any special fonts/shadows/colors in this stage. Try to make the functionalities clear and have a good balance of elements.</p>\n<p>1.2 High fidelity mockup</p>\n<p>Here’s comes the special part. The details will make or break your design, so it is not uncommon most time will be spend on the details.</p>\n<p>Colors\nFonts\nShadows\nIcons</p>\n<ol start=\"2\">\n<li>Setting up the project</li>\n</ol>\n<p>We will create this project using Visual Studio code as a text editor, you can use any you like but I prefer Visual Code because it gives you great feedback and has many extension possibilities.</p>\n<p>To test the project we need to use a test web server, we will use Node.js for this. Make sure you have node installed on your computer, you can download it for free from <a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a></p>\n<p>Same goes for Visual Studio Code, which you can download for free from <a href=\"https://code.visualstudio.com/download\">https://code.visualstudio.com/download</a></p>\n<p>Then we’ll also use Git and Github, which both are free.  You can download GIT from <a href=\"https://git-scm.com/downloads\">https://git-scm.com/downloads</a></p>\n<p>Then create an account if you don’t have one already on github.com and create a new repository, this is basically a folder where all you project data will be stored online and locally on your pc. We will call the repository ‘smartart’. Then go to your Github folder on your pc on also create a folder here called ‘smartart’.</p>\n<p>We will use the command prompt for managing our git project. Open up the command prompt and browse to your Github folder, in my case C:\\Users\\’username’\\Github. Then go to the smartart folder by using cd smartart (Windows users).</p>\n<p>We will initialize this repository by using git init in the command line and then npm init\nThen we’ll install the webpack package on our node server by using the following commands\nnpm install --save-dev webpack webpack-cli webpack-dev-server html-webpack-plugin </p>\n<p>Later when we have added our first files we will upload them to the remote (online) github repository.\nNow open up visual code and open your just created smartart folder by using the shortcut (ctr+k) + (ctrl+o).\nOpen up the package.json file to check if your packages are installed correctly:</p>\n<p>\"devDependencies\": {\n\"html-webpack-plugin\": \"^3.2.0\",\n\"webpack\": \"^4.41.2\",\n\"webpack-cli\": \"^3.3.10\",\n\"webpack-dev-server\": \"^3.9.0\"\n}</p>\n<p>Then remove the line in the scripts section and add the following:</p>\n<p>\"dev\": \"webpack --mode development\",\n\"build\": \"webpack --mode production\",\n\"start\": \"webpack-dev-server --mode development --open\"</p>\n<p>Then create a file called webpack.config.js and add the following: </p>\n<p>const path = require('path');</p>\n<p>module.exports = {\nentry: './src/js/index.js',\noutput: {\npath: path.resolve(__dirname, 'dist'),\nfilename: 'js/bundle.js'\n},\ndevServer: {\ncontentBase: './dist'\n},\n};\nplugins: [\nnew HtmlWebpackPlugin({\nfilename: 'index.html',\ntemplate: './src/index.html'\n})\n],</p>\n<p>Then add the following folders and files</p>\n<p>dist/js/\nsrc/js/index.js\nsrc/index.html\nsrc/css/main.scss</p>\n<p>In index.html type doc and press enter to load a standard HTML file.</p>\n<p>Then before the ending body tag add <script src=\"./js/bundle.js\"></script></p>\n<p>Let’s add some text on this page, for example <h1>Hello world</h1></p>\n<p>Now open up your src/js/index.js file and add the following</p>\n<p>const h1 = document.querySelector('h1');\nh1.style.color = 'red';</p>\n<p>Now use the command ctrl + ~  to open up the terminal in visual studio code.</p>\n<p>Type in npm start to open up your new project! Your text should turn red if everything went okay.</p>\n<p>We will use sass in our project so we need to add a package in our webpack project that converts scss to css.</p>\n<p>Run the command  npm install style-loader css-loader --save</p>\n<p>Then in index.js delete everything and add: import '../css/main.scss';</p>\n<p>Then fill in the following in main.scss to test if it is working:</p>\n<p>$color1: red;</p>\n<p>h1 {\ncolor: $color1;\n}</p>\n<p>Run npm start again and your h1 should be red!</p>\n<ol start=\"3\">\n<li>Creating the static HTML/CSS website</li>\n</ol>\n<p>3.1 Setting up the frame\nWe will first create our main element which is in the center of the page, we will use CSS grid on the body to set up the layout grid.</p>\n<p>Your index.html should look like this now:</p>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Art app</title>\n    <link rel=\"stylesheet\" href=\"./css/main.scss\">\n</head>\n<body>\n    \n    <div class=\"grid\">\n        <main class=\"main\">\n            <h>Test</h>\n        </main>\n    </div>\n    \n    <script src=\"./js/bundle.js\"></script>\n</body>\n</html>\n<p>Then in the main.scss add the following code to create the grid and main section. The repeat(12, 1fr) will split the whole page up in 12 equal sections. The box sizing border box will make sure the padding of a div won’t make the div bigger but add the padding inside the div itself.</p>\n<ul>\n<li>{\nmargin: 0;\npadding: 0;\nbox-sizing: border-box;\n}</li>\n</ul>\n<p>.grid {\nwidth: 100%;\nheight: 100%;\npadding: 5%;\n}</p>\n<p>.main {\nwidth: 100%;\nheight: 100%;\ndisplay: grid;\ngrid-template-columns: repeat(12, 1fr);\ngrid-template-rows: repeat(12, 1fr);\nbackground: lightcoral;\n}</p>\n<p>Now we will divide up the main part in three sections: the left settings bar, the bottom navigation and information part, and the main center art part. We will do this by placing three divs in the main grid on the right locations.</p>\n<p>Inside the main div add the following:</p>\n<pre><code> &#x3C;main class=\"main\">\n        &#x3C;section class=\"settings\">\n            &#x3C;h1>Settings&#x3C;/h1>\n        &#x3C;/section>\n        &#x3C;section class=\"art\">\n            &#x3C;h1>Art&#x3C;/h1>\n        &#x3C;/section>\n        &#x3C;section class=\"info\">\n            &#x3C;h1>info&#x3C;/h1>\n        &#x3C;/section>\n   &#x3C;/main>\n</code></pre>\n<p>Then in the main.scss add the following styles:</p>\n<p>.settings {\ngrid-column: 1 / span 4;\ngrid-row: 1 / span 12;\nbackground: lightgreen;\n}</p>\n<p>.art {\ngrid-column: 5 / span 8;\ngrid-row: 1 / span 8;\nbackground: lightpink;\n}</p>\n<p>.info {\ngrid-column: 5 / span 8;\ngrid-row: 9 / span 4;\nbackground: lightskyblue;\n}</p>\n<p>3.2 Creating the settings part</p>\n<p>Now we will add the text in the settings box and also include the fonts in main.scss. We do this by selecting our fonts on fonts.google.com and using the import code that it generates.</p>\n<p>Place the following in the top of main.scss:</p>\n<p>@import url('<a href=\"https://fonts.googleapis.com/css?family=Cormorant+Garamond:300,400,500,600,700%7CProza+Libre:400,500,600,700&#x26;display=swap&#x27;\">https://fonts.googleapis.com/css?family=Cormorant+Garamond:300,400,500,600,700|Proza+Libre:400,500,600,700&#x26;display=swap'</a>);</p>\n<p>Then add these variables for easier usage in our css file:</p>\n<p>$font1: 'Cormorant Garamond, serif';\n$font2: 'Proza Libre, sans-serif';</p>\n<p>$color1: #9e324e;\n$color2: #333;</p>\n<p>Now we can use these variables in our css, which is much easier if we want to change the color or the font in a later stage. Then give the grid a background of #f5f5f5 and the settings #f9f9f9.</p>\n<p>Add the following divs in your HTML file:</p>\n<div class=\"grid\">\n        <main class=\"main\">\n            <section class=\"settings\">\n                <h1 class=\"settings__h1\">smartart</h1>\n                <p class=\"settings__p\">Fill in your art preferences below and we will show you\n                recommendations. Then like or dislike art to improve\n                your recommendations.\n                </p>\n                <h6 class=\"settings__h6\">Classification</h6>\n                    <div class=\"box__item active\">history</div>\n                    <div class=\"box__item\">portrait</div>\n                    <div class=\"box__item\">landscape</div>\n                    <div class=\"box__item\">still life</div>\n                    <div class=\"box__item\">genre</div>\n                <h6 class=\"settings__h6\">Period</h6>\n                    <div class=\"box__item active\">modern</div>\n                    <div class=\"box__item\">imperial</div>\n                    <div class=\"box__item\">roman</div>\n                    <div class=\"box__item\">crusdar</div>\n            </section>\n            <section class=\"art\">\n                <h1>Art</h1>\n            </section>\n            <section class=\"info\">\n                <h1>info</h1>\n            </section>\n        </main>\n    </div>\n<p>Then make sure your settings css looks like this. The buttons won’t be actual buttons or a-tags, we will create them ourselves with javascript. The display inline-block make them sort nicely behind each other. Next up we will add animation to the buttons. You’ll see that with SASS you can use nested styles, which has its benefits.</p>\n<p>.settings {\ngrid-column: 1 / span 4;\ngrid-row: 1 / span 12;\npadding: 3em;\nbackground: #fefefe;\n.settings<strong>h1 {\nfont-family: $font1;\nfont-size: 3.5em;\npadding-bottom: 1rem;\n}\n.settings</strong>h6 {\nfont-size: .9em;\npadding: 2.5rem 0 1rem 0;\n}\n.box__item {\nborder: 1px solid #ccc;\npadding: .8rem;\nmargin: .2rem 0 .2rem 0;\ndisplay: inline-block;\n&#x26;.active {\nborder: none;\nbackground: $color1;\ncolor: white;\n}\n}\n}</p>\n<p>For the button animation we will create a so called pseudo element, which is basically just a simple new div before or after our div. Make sure you set the position of the box item to relative and of the pseudo element to absolute to make sure it’s near the box item itself. Then a litte trick, set the after element zo z-index: -1 and the box item to z-index: 1. Then add the following code which will make the hover effect.</p>\n<p>.box__item {\nborder: 1px solid #ccc;\npadding: .8rem;\nmargin: .2rem 0 .2rem 0;\ndisplay: inline-block;\nposition: relative;\ncursor: pointer;\nz-index: 1;\n&#x26;.active {\nborder: none;\nbackground: $color1;\ncolor: white;\n}\n&#x26;::after {\ncontent: '';\nposition: absolute;\ntop: 0;\nleft: 0;\nwidth: 100%;\nheight: 100%;\nbackground: rgba(0, 0, 0, .1);\nz-index: -1;\ntransition: transform 175ms ease-in;\ntransform: scaleX(0);\ntransform-origin: left;\n}\n&#x26;:hover:after  {\ntransform: scaleX(1);\n}\n}</p>\n<p>Let’s add the main button now.</p>\n<p>Let’s check how our app looks on mobile, currently not so good:</p>\n<p>Let’s fix this. This will actually be really easy thanks to CSS flexbox. We will add a media query for screens smaller than 1200px on the main element. We will change the grid to a flexbox and set the direction to column, so instead of the grid we will just have the divs stacked on each other. Nest the following code within the main class in your css file:</p>\n<p>@media all and (max-width: 1200px) {\ndisplay: flex;\nflex-direction: column;\n}</p>\n<p>That’s it! Works perfectly on mobile.</p>\n<p>Now add the following div the settings section:</p>\n<div class=\"box\">\n                    <div class=\"box__item generate\">generate</div>\n                </div>\n<p>With this styling. The justify content decides on which side the div inside should be placed, in our case at the end of the parent div. If you also want to center the div you can use align-items: center also.</p>\n<p>.box {\npadding-top: 1rem;\nwidth: 100%;\ndisplay: flex;\njustify-content: flex-end;\n.generate {\nbackground: #333;\ncolor: white;\n}\n}</p>\n<p>3.3 Information part\nSettings part is done. Let’s make the information part. Basically there are 5 elements within the information part: two arrows, the year, the artist and the subtitle. Let’s add them to the HTML and then create the CSS for it. This should be enough. I’m using the free ionicons, which you can get from <a href=\"https://ionicons.com/usage\">https://ionicons.com/usage</a></p>\n<pre><code>     &#x3C;section class=\"info\">\n            &#x3C;div class=\"year\">1888&#x3C;/div>\n            &#x3C;div class=\"circle__wrapper\">\n                &#x3C;div class=\"circle\">\n                    &#x3C;ion-icon name=\"arrow-back\">&#x3C;/ion-icon>\n                &#x3C;/div>\n            &#x3C;/div>\n            &#x3C;div class=\"content\">\n                &#x3C;h2 class=\"content__h2\">Vincent van Gogh&#x3C;/h2>\n                &#x3C;h5 class=\"content__h5\">Self-Portrait Dedicated to Paul Gauguin&#x3C;/h5>\n            &#x3C;/div>\n            &#x3C;div class=\"circle__wrapper\">\n                &#x3C;div class=\"circle\">\n                    &#x3C;ion-icon name=\"arrow-back\">&#x3C;/ion-icon>\n                &#x3C;/div>\n            &#x3C;/div>\n        &#x3C;/section>\n</code></pre>\n<p>Without CSS</p>\n<p>With CSS</p>\n<p>Then add the following CSS for the information box:</p>\n<p>.info {\ngrid-column: 5 / span 8;\ngrid-row: 9 / span 4;\nbackground: #f1f1f1;\ndisplay: flex;\njustify-content: center;\nalign-items: center;\nposition: relative;\n.year {\nfont-family: $font1;\ncolor: #ccc;\nopacity: .5;\nposition: absolute;\nfont-size: 13em;\nmargin-top: -18vh;\nleft: 1vw;\n}\n.content {\nwidth: 100vw;\ndisplay: flex;\nflex-direction: column;\njustify-content: center;\nalign-items: center;\n.content<strong>h2 {\nfont-family: $font1;\nfont-size: 3.5em;\n}\n.content</strong>h5 {\npadding-top: .5rem;\nfont-size: 1.1em;\ncolor: $color1;\n}\n}\n.circle<strong>wrapper {\nwidth: 100%;\ndisplay: flex;\njustify-content: center;\nalign-items: center;\n}\n.circle {\nwidth: 10vh;\nheight: 10vh;\nborder-radius: 50%;\ndisplay: flex;\nalign-items: center;\njustify-content: center;\nbackground: $color1;\n.circle</strong>icon {\ncolor: white;\nfont-size: 24px;\n}\n}\n}</p>\n<p>How can we make the second arrow look to the right? We can do this with CSS by using transform: rotate by nesting the following code within .circle__wrapper:</p>\n<pre><code>   &#x26;:last-child .circle .circle__icon {\n        transform: rotate(180deg);\n    }\n</code></pre>\n<p>We also need to add a hover effect on the circle arrows. Let’s make it slightly bigger, add this to the .circle class:</p>\n<p>transition: all 175ms ease;</p>\n<p>And then next in the hover effect:</p>\n<p>&#x26;:hover {\nbox-shadow: 5px 5px 10px rgba(0, 0, 0, .3);\ntransform: scale(1.1);\n}</p>\n<p>Let’s check mobile again, it’s important to do this regularly so we don’t have to get back into every part at the end. We should add some media queries. On the info div we will do the same trick as we did on the main element. Then on the content and the year we will add some padding and margins to make it look better.</p>\n<p>.year\n@media all and (max-width: 1200px) {\nmargin-top: -32vh;\n}\n.content\n@media all and (max-width: 1200px) {\npadding: 1em 4em;\n}\n.info </p>\n<p>@media all and (max-width: 1200px) {\ndisplay: flex;\nflex-direction: column;\n}</p>\n<p>3.4 Art part\nNow let’s create the actual part for the paintings. Basically this will be a div which holds 5 div that we can scroll.</p>\n<p>First we will add some example picture in our HTML:</p>\n<section class=\"art\">\n                <div class=\"painting\" data-id=\"1\">\n                    <img src=\"https://images-na.ssl-images-amazon.com/images/I/81HOBLQO%2BgL._SY679_.jpg\">\n                </div>\n                <div class=\"painting\" data-id=\"2\">\n                    <img src=\"https://storage.googleapis.com/ehimages/2017/10/25/img_942b5703ed4c5d3b242a34f7cc87d9c0_1508933938684_processed_original.jpg\">\n                </div>\n                <div class=\"painting\" data-id=\"3\">\n                    <img src=\"https://cdn.eventfinda.co.nz/uploads/events/transformed/1276619-567973-14.jpg\">\n                </div>\n                <div class=\"painting\" data-id=\"4\">\n                    <img src=\"https://images-na.ssl-images-amazon.com/images/I/81HOBLQO%2BgL._SY679_.jpg\">\n                </div>\n                <div class=\"painting\" data-id=\"5\">\n                    <img src=\"https://storage.googleapis.com/ehimages/2017/10/25/img_942b5703ed4c5d3b242a34f7cc87d9c0_1508933938684_processed_original.jpg\">\n                </div>\n            </section>\n<p>Then we’ll apply the following styles on it. The overflow: hidden makes sure the div slide only in the art div box.</p>\n<p>.art {\ngrid-column: 5 / span 8;\ngrid-row: 1 / span 8;\nbackground: #f9f9f9;\ndisplay: flex;\nalign-items: center;\njustify-content: center;\noverflow: hidden;\n@media all and (max-width: 1200px) {\nmin-height: 500px;\n}\nimg {\nmax-height: 30vh;\nmax-width: 20vw;\n@media all and (max-width: 1200px) {\nmax-height: 300px;\nmax-width: 300px;\n}\n}\n.painting {\nmargin: 0 5em;\n}\n}</p>\n<p>We have finished creating our static HTML/CSS website!</p>\n<p>First commit to Github\nFirst create a file called .gitignore in the main folder and add the following text: node_modules\nThis will skip all the node modules folders to your github folder.</p>\n<p>Press ctrl + ~ to open the terminal in Visual Code and then type in the following commands\n$ git add .\n$ git commit -m ‘first commit’\n$ git remote add origin <a href=\"https://github.com/\">https://github.com/</a><youraccountname>/smartart.git\n$ git push -u origin master</p>\n<p>Now you’re files are pushed to your remote github repository.</p>\n<ol start=\"4\">\n<li>Setting up the events</li>\n</ol>\n<p>Next up we will make the navigation working and the buttons selectable.</p>\n<p>4.1 Buttons</p>\n<p>Let’s select all our buttons in index.js:</p>\n<p>const buttons = document.querySelectorAll('.box__item');</p>\n<p>Then add an event listener to track clicks for each of the buttons by looping over them and adding a function btnClick() to each button click. Note that the function does not contain the () because it is not directly invoked, only when the click is called.</p>\n<p>buttons.forEach(button => button.addEventListener('click', btnClick));</p>\n<p>To toggle the active class on each button, we add the following code:</p>\n<p>const btnClick = (event) => {\nevent.target.classList.toggle(\"active\");\n}</p>\n<p>Because the btnClick function is a declared function, it is not hoisted as first in the javascript execution context. This basically means we need to write it before we add our eventlistener, otherwise they can not find the function to execute.</p>\n<p>4.2 Painting slider</p>\n<p>We currently have five example paintings which need to slide whenever we click the arrows. First we wrap our slides in a new div called art__wrapper which we will give the following nested slides, instead of the art section:</p>\n<p>.art__wrapper {\ndisplay: flex;\nalign-items: center;\njustify-content: center;\n}</p>\n<p>Now we can control the painting the user is viewing by moving the wrapper left or right with margins.</p>\n<p>Let’s select our arrows and add event listeners to them:</p>\n<p>const arrowLeft = document.querySelector('.circle<strong>left');\nconst arrowRight = document.querySelector('.circle</strong>right');</p>\n<p>const slide = (target) => {\nconsole.log(target);\n}</p>\n<p>arrowLeft.addEventListener('click', slide);\narrowRight.addEventListener('click', slide);</p>\n<p>Now we need to know in our function if the right or the left slide has been pressed. The user can also click the arrow icon which does not contain a left or right indication. We can solve this by grabbed the parentNode of the icon:</p>\n<p>const slide = (event) => {\nlet direction;\nif (event.target.classList.contains(\"circle<strong>left\") || event.target.parentNode.classList.contains(\"circle</strong>left\")) {\ndirection = 'left';\n} else {\ndirection = 'right';\n}\nconsole.log(direction);\n}</p>\n<p>Add a querySelector on the art wrapper. Then we need to get the current margin left and then add some to it to move the painting. We can do this by the currentstyle property or the getComputedStyle (if not microsoft). Then we parse this string to a number.</p>\n<p>if (event.target.classList.contains(\"circle<strong>left\") || event.target.parentNode.classList.contains(\"circle</strong>left\")) {\n// LEFT\nconst style = artWrapper.currentStyle || window.getComputedStyle(artWrapper);\nlet currentMargin = parseInt(style.marginLeft.replace('px', ''));\nartWrapper.style.marginLeft = currentMargin + 200;\n} else {\n// RIGHT\n}</p>\n<p>We do not want our users the be able to scroll forever so we need to limit the amount they can scroll. We can do this by checking the amount of paintings and their total width including margins. First add a query selector for all the paintings. Our total slide functionality now looks like this:</p>\n<p>const arrowLeft = document.querySelector('.circle<strong>left');\nconst arrowRight = document.querySelector('.circle</strong>right');\nconst artWrapper = document.querySelector('.art__wrapper');\nconst paintings = document.querySelectorAll('.painting');</p>\n<p>const slide = (event) => {\nlet direction, currentMargin, maxWidth;</p>\n<pre><code>maxWidth = (paintings.length) * 300;\n\nconst style = artWrapper.currentStyle || window.getComputedStyle(artWrapper);\ncurrentMargin = parseInt(style.marginLeft.replace('px', ''));\n\nif (event.target.classList.contains(\"circle__left\") || event.target.parentNode.classList.contains(\"circle__left\")) {\n    // LEFT\n    let currentMargin = parseInt(style.marginLeft.replace('px', ''));\n    if (currentMargin &#x3C; maxWidth) artWrapper.style.marginLeft = currentMargin + 300;\n\n} else {\n    // RIGHT\n    let currentMargin = parseInt(style.marginLeft.replace('px', ''));\n    if (currentMargin > (maxWidth * -1)) artWrapper.style.marginLeft = currentMargin - 300;\n}\n</code></pre>\n<p>}</p>\n<p>arrowLeft.addEventListener('click', slide);\narrowRight.addEventListener('click', slide);</p>\n<p>And that’s it for the event listeners! In the next section we will change our code to the MVC model and set the state.</p>\n<ol start=\"5\">\n<li>Adding MVC and state</li>\n</ol>\n<p>5.1 Setting up a MVC model</p>\n<p>Although setting up the model, view and controller system is a lot of work for just this small app, it is good to practise and get familiar with MVC. The model manages the data of the application, the view manages what actually get displayed on screen and the controller connect the two. The model never touches the view. The view never touches the model. The controller connects them. Create two news folders within your /js folder called models and views. We do not have a model yet (which stores and manages data) so we will start with the view. Create two new files inside the views folder called elements.js and painting.js. Elements will contain all our query selectors.</p>\n<p> Add the following query selectors in elements.js:</p>\n<p>export const elements = {\nsettings: document.querySelector('.settings'),\nbuttons: document.querySelectorAll('.box<strong>item'),\narrowLeft: document.querySelector('.circle</strong>left'),\narrowRight: document.querySelector('.circle<strong>right'),\nartWrapper: document.querySelector('.art</strong>wrapper'),\npaintings: document.querySelectorAll('.painting'),\ngenerate: document.querySelector('.box__generate'),\nclassification: document.querySelector('.classification'),\nperiod: document.querySelector('.period'),\n};</p>\n<p>Now we can import these files in index.js by adding the following in the top of the page:</p>\n<p>import { elements } from './views/elements';\nimport * as paintings from './views/paintingView';</p>\n<p>Place the code of the painting slider inside views/paintingView.js file.</p>\n<p>So it looks like this:</p>\n<p>import { elements } from './elements';</p>\n<p>// SLIDE FUNCTIONALITY </p>\n<p>export const slide = (event) => {\nlet direction, currentMargin, maxWidth;</p>\n<pre><code>maxWidth = (elements.paintings.length) * 300;\n\nconst style = elements.artWrapper.currentStyle || window.getComputedStyle(elements.artWrapper);\ncurrentMargin = parseInt(style.marginLeft.replace('px', ''));\n\nif (event.target.classList.contains(\"circle__left\") || event.target.parentNode.classList.contains(\"circle__left\")) {\n    // LEFT\n    let currentMargin = parseInt(style.marginLeft.replace('px', ''));\n    if (currentMargin &#x3C; maxWidth) elements.artWrapper.style.marginLeft = currentMargin + 300;\n\n} else {\n    // RIGHT\n    let currentMargin = parseInt(style.marginLeft.replace('px', ''));\n    if (currentMargin > (maxWidth * -1)) elements.artWrapper.style.marginLeft = currentMargin - 300;\n}\n</code></pre>\n<p>};</p>\n<p>5.2 Creating state </p>\n<p>Let’s start working on the settings section. The preferences of the user should be stored and saved somewhere while the user is using the application. We can do this in a new object which we call the state. Let’s add an empty object in index.js called state.</p>\n<p>const state = {};</p>\n<p>Add a query selector in elements for our generate button. Then in index.js add:</p>\n<p>// SAVE NEW SETTINGS\nconst controlSettings = () => {</p>\n<pre><code>// Retrieve settings from settingsView\nconst newSettings = settingsView.getSettings();\n\n// Update state with new settings\nstate.settings.userSettings = newSettings;\n</code></pre>\n<p>}</p>\n<p>elements.generate.addEventListener('click', controlSettings);</p>\n<p>Now create a new file called settingsView.js where we will render the setting items and also retrieve the new settings when the generate button is called:</p>\n<p>import { elements } from './elements';</p>\n<p>export const renderSettings = (data, type) => {\nconst markup = <code>&#x3C;div data-type=\"${type}\" class=\"box__item\">${data}&#x3C;/div></code>;\ntype === 'classification' ?\nelements.classification.insertAdjacentHTML('afterend', markup)\n: elements.period.insertAdjacentHTML('afterend', markup)\n}</p>\n<p>export const getSettings = () => {\nconst userSettings = {\nclassification: [],\nperiod: []\n}\nconst active = document.querySelectorAll('.box__item.active');\nactive.forEach(item => {\nconst value = item.innerHTML;\nconst type = item.dataset.type;\nif (type === 'classification') {\nuserSettings.classification.push(value);\n} else if (type === 'period') {\nuserSettings.period.push(value);\n}\n})\nreturn userSettings;\n}</p>\n<p>Then we will create the file that stores our settings in /models/Settings.js:</p>\n<p>export class Settings {\nconstructor() {\nthis.userSettings = {\nclassification: [],\nperiod: []\n}\n}\n}</p>\n<p>And store our default data in /models/Data.js:</p>\n<p>export const data = {\nclassification: ['history', 'portrait', 'landscape', 'still life', 'genre'],\nperiod: ['modern', 'imperial', 'roman', 'crusdar']\n}</p>\n<p>In index.js we will now initialize our app by calling the settings items and creating a new settings instance object.</p>\n<p>import '../css/main.scss';\nimport Settings from './models/Settings';\nimport { data } from './models/Data';\nimport { elements } from './views/elements';\nimport * as paintings from './views/paintingView';\nimport * as settingsView from './views/settingsView';</p>\n<p>const state = {};</p>\n<p>// INIT APPLICATION\nconst init = () => {\nif (!state.settings) state.settings = new Settings();</p>\n<pre><code>// Render data on screen\ndata.classification.forEach((el, i) => {\n    settingsView.renderSettings(data.classification[i], 'classification');\n})\n\ndata.period.forEach((el, i) => {\n    settingsView.renderSettings(data.period[i], 'period');\n})\n</code></pre>\n<p>}</p>\n<p>init();</p>\n<p>The toggle functionality on the buttons is now not working anymore because they are rendered after this code has been executed. So we need to call an event listener on it’s parent and then listen if any of the children is called, we call this event bubbling:</p>\n<p>// TOGGLE BUTTONS - CHECK CHANGES IN SETTINGS\nelements.settings.addEventListener('click', (e) => {\nif (!e.target.classList.contains('box<strong>generate')) {\nconst target = e.target.closest('.box</strong>item');\ntarget.classList.toggle(\"active\");\n}\n})</p>\n<ol start=\"6\">\n<li>Setting up the API</li>\n</ol>\n<p>Let’s start with creating a new folder outside our smartart folder called smartart-api.</p>\n<p>6.1 Adding a loader spinner</p>\n<p>For retrieving data from the API we need an asynchronous function, because we do not want the rest of our code to stop. Change the controlsettings function in index to the following:</p>\n<p>// SAVE NEW SETTINGS\nconst controlSettings = async () => {</p>\n<pre><code>// Remove current paintings\npaintingView.clear();\n\n// Render loader icon\npaintingView.renderLoader();\n\n// Retrieve settings from settingsView\nconst newSettings = settingsView.getSettings();\n\n// Update state with new settings\nstate.settings.userSettings = newSettings;\n\n// New Search object and add to state\nstate.search = new Search(newSettings);\n\npaintingView.renderPaintings('test');\n</code></pre>\n<p>}</p>\n<p>Now we will add the methods in the paintingView file by adding the following code:</p>\n<p>// CLEAR PAINTINGS</p>\n<p>export const clear = () => {\nelements.paintings.forEach(painting => {\npainting.style.opacity = 0;\n})\n}</p>\n<p>// RENDER LOADER</p>\n<p>export const renderLoader = () => {\nconst loader = '<div class=\"lds-dual-ring\"></div>';\nelements.artWrapper.insertAdjacentHTML('afterbegin', loader);\n}</p>\n<p>Our elements.js now contains a couple more query selectors:</p>\n<p>export const elements = {\nsettings: document.querySelector('.settings'),\nbuttons: document.querySelectorAll('.box<strong>item'),\narrowLeft: document.querySelector('.circle</strong>left'),\narrowRight: document.querySelector('.circle<strong>right'),\nartWrapper: document.querySelector('.art</strong>wrapper'),\npaintings: document.querySelectorAll('.painting'),\npaintingImg: document.querySelectorAll('.painting img'),\ngenerate: document.querySelector('.box__generate'),\nclassification: document.querySelector('.classification'),\nperiod: document.querySelector('.period'),\n};</p>\n<p>And add the following code for the loader spinner in main.scss:</p>\n<p>// Loader spinner\n.lds-dual-ring {\ndisplay: inline-block;\nwidth: 80px;\nheight: 80px;\nposition: absolute;\nz-index: 1;\ncolor: $color1;\n}\n.lds-dual-ring:after {\ncontent: \" \";\ndisplay: block;\nwidth: 64px;\nheight: 64px;\nmargin: 8px;\nborder-radius: 50%;\nborder: 6px solid $color1;\nborder-color: $color1 transparent $color1 transparent;\nanimation: lds-dual-ring 1.2s linear infinite;\n}\n@keyframes lds-dual-ring {\n0% {\ntransform: rotate(0deg);\n}\n100% {\ntransform: rotate(360deg);\n}\n}</p>\n<p>6.2 Retrieving new paintings from the Harvard Art API</p>\n<p>We first need to get our API key from Harvard. You can get one here: <a href=\"https://www.harvardartmuseums.org/collections/api\">https://www.harvardartmuseums.org/collections/api</a></p>\n<p>Then we can go to the documentation and see what we have to do:\n<a href=\"https://github.com/harvardartmuseums/api-docs\">https://github.com/harvardartmuseums/api-docs</a></p>\n<p>But let’s first set up our API call in our application. Add the following code in the controlSettings method:</p>\n<p>// Retrieve paintings\ntry {\n// 4) Search for paintings\nawait state.search.getPaintings();</p>\n<pre><code>    // 5) Render results\n    paintingView.renderPaintings(state.search.result);\n    \n} catch (err) {\n    alert('Something wrong with the search...');\n}\n</code></pre>\n<p>Then run the command npm install axios this will make it easier for us to do API calls. Then make sure your /models/Search.js looks like this:</p>\n<p>import axios from 'axios';\nimport { key } from '../config';</p>\n<p>export default class Search {\nconstructor(query) {\nthis.query = query;\n}</p>\n<pre><code>async getResults() {\n    try {\n        const res = await axios(`${proxy}http://food2fork.com/api/search?key=${key}&#x26;q=${this.query}`);\n        this.result = res.data.recipes;\n        // console.log(this.result);\n    } catch (error) {\n        alert(error);\n    }\n}\n</code></pre>\n<p>}</p>\n<p>In the main JS folder, create a file called config.js - here we will place our API key.</p>\n<pre><code>export const key = ‘...’;\n</code></pre>\n<p>We first nee</p>\n<p>We want to retrieve at least:\nThe image path\nName of the artist\nName of the painting</p>\n<p>Let’s check how we can do that. With an object we have all the information we need:\n<a href=\"https://github.com/harvardartmuseums/api-docs/blob/master/sections/object.md\">https://github.com/harvardartmuseums/api-docs/blob/master/sections/object.md</a></p>\n<p>We will try to run a query in Search.js using the following code</p>\n<p>async getPaintings() {\ntry {\nconst res = await axios(<code>https://api.harvardartmuseums.org/object?person=33430&#x26;apikey=${key}</code>);\nthis.result = res.data;\nconsole.log(this.result);\n} catch (error) {\nalert(error);\n}\n}</p>\n<p>Press generate in the app and check your console.log, it works! We received an object will all kinds of data. Now let’s build the correct query.</p>\n<p>6.3 Retrieving data based on users input</p>\n<p>Now we need to actually have the real classifications and periods which Harvard Art uses. Let’s get them from the website so your data file looks like this.</p>\n<p>export const data = {\nclassification: ['Paintings', 'Photographs', 'Drawings', 'Vessels', 'Prints'],\nperiod: ['Middle Kingdom', 'Bronze Age', 'Roman period', 'Iron Age']\n}</p>\n<p>Our complete Search.js now looks like:</p>\n<p>import axios from 'axios';\nimport { key } from '../config';</p>\n<p>export default class Search {\nconstructor(settings) {\nthis.settings = settings;\n}</p>\n<pre><code>buildQuery(settings) {\n    let classification = [];\n    settings.classification.forEach(el => classification.push('&#x26;classification=' + el));\n    classification = classification.toString();\n\n    let period = [];\n    settings.period.forEach(el => period.push('&#x26;period=' + el));\n    period = period.toString();\n\n    let query = classification + period;\n    query = query.replace(',', '');\n    this.query = query;\n}\n\nasync getPaintings() {\n    try {\n        this.buildQuery(this.settings);\n        const res = await axios(`https://api.harvardartmuseums.org/object?apikey=${key}${this.query}`);\n        console.log(res);\n        this.result = res.data.records;\n        console.log(this.result);\n    } catch (error) {\n        alert(error);\n    }\n}\n</code></pre>\n<p>}</p>\n<p>With our buildQuery function we are setting up our query based on the user settings.</p>\n<p>Now let’s render the resulting paintings on the screen, update your renderPaintings function in paintingView with the following:</p>\n<p>export const renderPaintings = paintings => {</p>\n<pre><code>// Remove loader\nconst loader = document.querySelector(`.lds-dual-ring`);\nif (loader) loader.parentElement.removeChild(loader);\n\nconsole.log(paintings);\n\n// Replace paintings\nelements.paintingImg.forEach((img, i) => {\n    img.src = paintings[i].primaryimageurl;\n})\n\n// Show paintings again\nelements.paintings.forEach(painting => {\n    painting.style.opacity = 1;\n})\n</code></pre>\n<p>}</p>\n<p>6.4 Combining different user preferences</p>\n<p>We have a bug now,  we can not combine any classifications or periods with each other. Only single requests e.g. period=Iron Age is possible unfortunately with the API. We will solve this by limiting the user to 1 classification and 1 period. Then we will filter the data by period.\nWe can limit the classification and period by changing our button toggle function:</p>\n<p>elements.settings.addEventListener('click', (e) => {\nif (!e.target.classList.contains('box<strong>generate')) {\nconst activeClassification = document.querySelector('.box</strong>item.active[data-type=\"classification\"]');\nconst activePeriod = document.querySelector('.box<strong>item.active[data-type=\"period\"]');\nconst target = e.target.closest('.box</strong>item');\nif (target.dataset.type == 'classification' &#x26;&#x26; activeClassification) {\nsettingsView.toggle(activeClassification);\n}\nif (target.dataset.type == 'period' &#x26;&#x26; activePeriod) {\nsettingsView.toggle(activePeriod);\n}\nsettingsView.toggle(target);\n}\n})</p>\n<p>And adding the settingsView.toggle method:</p>\n<p>export const toggle = target => {\ntarget.classList.toggle(\"active\");\n}</p>\n<p>Now the classification part is working! Let’s filter our data if the user has select a period.</p>\n<p>Not so many object actually have a period, so lets change the period to century. You can make a folder wide replace in visual code by using SHIFT+CTRL+F and then search and replace for ‘period’ to ‘century’.</p>\n<p>Now the data.js file looks like:</p>\n<p>export const data = {\nclassification: ['Paintings', 'Jewelry', 'Drawings', 'Vessels', 'Prints'],\ncentury: ['16th century', '17th century', '18th century', '19th century', '20th century']\n}</p>\n<p>Then remove /models/Settings.js as we do not need the settings state anymore, the search state is enough. Also remove it in the index.js file.</p>\n<p>Our complete Search.js file then looks like</p>\n<p>import axios from 'axios';\nimport { key } from '../config';</p>\n<p>export default class Search {\nconstructor(settings) {\nthis.settings = settings;\n}</p>\n<pre><code>filterByCentury(results) {   \n    const century = this.settings.century.toString();\n    const filtered = results.filter(result => result.century == century);\n    return filtered;\n}\n\nasync getPaintings() {\n    try {\n        this.classification = this.settings.classification;\n        const res = await axios(`https://api.harvardartmuseums.org/object?apikey=${key}&#x26;classification=${this.classification}&#x26;size=100`);\n        this.result = this.filterByCentury(res.data.records);\n    } catch (error) {\n        alert(error);\n    }\n}\n</code></pre>\n<p>}</p>\n<p>Now we can filter the classification that the user has chosen. The resulting artworks are the same every time, let’s make them random by adding a randomize method in Search.js</p>\n<p>randomize(data, limit) {\nlet result = [];\nlet numbers = [];\nfor (let i = 0; i &#x3C;= limit; i++) {\nconst random = Math.floor(Math.random() * data.length);\nif (numbers.indexOf(random) === -1) {\nnumbers.push(random);\nresult.push(data[random]);\n}\n}\nconsole.log('result', result);\nreturn result;\n}</p>\n<p>We can filter the limit the data we get back from randomize by the limit variable. The other methods then look like:</p>\n<p>filterByCentury(results) {<br>\nconst century = this.settings.century.toString();\nconst filtered = results.filter(result => result.century == century);\nconst result = this.randomize(filtered, 5);\nreturn result;\n}</p>\n<pre><code>async getPaintings() {\n    try {\n        this.classification = this.settings.classification.toString();\n        const res = await axios(`https://api.harvardartmuseums.org/object?apikey=${key}&#x26;classification=${this.classification}&#x26;size=100`);\n        this.result = this.filterByCentury(res.data.records);\n    } catch (error) {\n        alert(error);\n    }\n}\n</code></pre>\n<p>Then we need to update out paintingView.js:</p>\n<p> // RENDER PAINTINGS</p>\n<p>export const renderPaintings = paintings => {</p>\n<pre><code>console.log('paintings', paintings);\n\n// Show paintings again\nelements.paintings.forEach(painting => {\n    painting.style.opacity = 1;\n})\n\n// Replace paintings\n\npaintings.forEach((painting, i) => {\n    const imgPath = paintings[i].primaryimageurl;\n    if(imgPath) elements.paintingImg[i].src = imgPath;\n})\n\n// Remove loader\nconst loader = document.querySelectorAll(`.lds-dual-ring`);\nif (loader) {\n    loader.forEach(loader => loader.parentElement.removeChild(loader));\n}\n</code></pre>\n<p>}</p>\n<p>6.5 Loading default artworks</p>\n<p>To load a default query we will add the following method to the init function:</p>\n<p>// Render default artworks\nsettingsView.renderDefault('Prints', '20th century');\ncontrolSettings();</p>\n<p>And the in settingsView we will make the selected items active by toggling their classes. We have to select them again because they are rendered later than elements.js select them.</p>\n<p>export const renderDefault = (classification, century) => {\nconst buttons = document.querySelectorAll('.box__item');\nbuttons.forEach(button => {\nif (button.innerHTML == classification || button.innerHTML == century) {\nbutton.classList.toggle('active');\n}\n})\n}</p>\n<p>Let’s improve our error handling. We can do this by throwing an error back when no images have been found. Also we will place a loading spinner remove function outside the renderPaintings function so we can call it from the controller.</p>\n<p>// RENDER PAINTINGS\nexport const renderPaintings = paintings => {</p>\n<pre><code>if (paintings.length > 1) {\n\n    // Show paintings again\n    elements.paintings.forEach(painting => {\n        painting.style.opacity = 1;\n    })\n\n    // Replace paintings\n    paintings.forEach((painting, i) => {\n        const imgPath = paintings[i].primaryimageurl;\n        if(imgPath) elements.paintingImg[i].src = imgPath;\n    })\n\n} else {\n    throw \"No images found\";\n}\n</code></pre>\n<p>}</p>\n<p>// Remove loader\nexport const removeLoader = () => {\nconst loader = document.querySelectorAll(<code>.lds-dual-ring</code>);\nif (loader) {\nloader.forEach(loader => loader.parentElement.removeChild(loader));\n}\n}</p>\n<ol start=\"7\">\n<li>Art detail information</li>\n</ol>\n<p>In this section we will create the bottom part where information about the artwork is displayed, which is currently hard coded information.</p>\n<p>7.1 Setting up event listener</p>\n<p>Let’s add three new query selector in our elements.js file</p>\n<p>year: document.querySelector('.year'),\nartist: document.querySelector('.content<strong>h2'),\ntitle: document.querySelector('.content</strong>h5')</p>\n<p>Then create a new view file called detailView.js. Here we will add the renderDetails method which we will call in index.js after the user has clicked on an artwork.</p>\n<p>In the renderPaintings method we will now set the year, title and description as data attributes on the parent div of the image by the following code:</p>\n<p>// Replace paintings\npaintings.forEach((painting, i) => {\nconst imgPath = paintings[i].primaryimageurl;\nconst artist = paintings[i].title;\nconst year = paintings[i].accessionyear;\nconst desc = paintings[i].medium;\nif(imgPath) {\nelements.paintingImg[i].src = imgPath;\nelements.paintingImg[i].parentNode.setAttribute('data-year', year);\nelements.paintingImg[i].parentNode.setAttribute('data-desc', desc);\nelements.paintingImg[i].parentNode.setAttribute('data-artist', artist);\n}\n})</p>\n<p>In index.js we will then send the clicked painting information to the renderDetails function:</p>\n<p>// GET ART DETAILS\nlet newPaintings = document.querySelectorAll('.painting');\nnewPaintings.forEach(painting => {\npainting.addEventListener('click', () => {\nrenderDetails(painting)\n});\n});</p>\n<p>In detailView.js we can then easily update our detail information:</p>\n<p>import { elements } from './elements';</p>\n<p>export const renderDetails = painting => {\nelements.year.innerHTML = painting.dataset.year;\nelements.artist.innerHTML = painting.dataset.artist;\nelements.title.innerHTML = painting.dataset.desc;\n}</p>\n<p>Great! Our detail information is working.</p>\n<p>7.2 Fixing text breaking</p>\n<p>Some artworks have a long title and description which breaks our layout:</p>\n<p>Let’s set the font of .info .content .content__h2 to 2.3em so it still looks good on mobile.</p>\n<ol start=\"8\">\n<li>Adding likes to local storage</li>\n</ol>\n<p>In this section we will add like abilities to each rendered painting, so we can give the user more relevant artworks in their following rendered. We will keep track of our like ratio to see if we are actually recommending better artworks. We will store this information in the local storage of the users browser, which will stay there even after they have closed the website.</p>\n<p>8.1 Rendering likes per painting</p>\n<p>Content</p>\n<p>8.2 Saving likes and storing them in localStorage</p>\n<p>Content</p>\n<p>8.3 Recommending better artworks based on likes</p>\n<p>Content</p>\n<p>8.4 Calculating like ratio per result</p>\n<p>Content</p>\n<p>8.5 Rendering like ratio to the user</p>\n<p>content</p>\n<ol start=\"9\">\n<li>Deployment</li>\n</ol>\n<p>content</p>\n<p>9.1 ss</p>\n<p>Content</p>"}},"seoTitle":"Making a self learning art application using Harvard Art API","seoDescription":"Making a self learning art application using Harvard Art API","seoAuthor":"Sander de Bruijn","seoKeywords":"travel, travel photography, travel blog","seoImage":{"fluid":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAACAAFB//EACUQAAEEAQMEAgMAAAAAAAAAAAECAwQRBQAHIQYSE2EUQRUx0f/EABYBAQEBAAAAAAAAAAAAAAAAAAQBAv/EABoRAQEAAgMAAAAAAAAAAAAAAAECAAMEEWH/2gAMAwEAAhEDEQA/AHNP3TjJd8LuHfAQhJLwksFIskVZXZ+qPvmv3rncje8zi6zM6QlMrK3EtqkS4QQ6AkqSbD5ruHA+75IA50ZMPlZpweRUZj5V4lGy6q7tPvWT1PlJiekJLolvh38hHHeHFd1fFc4u9D176YK9DF3pCk8XElI3ifjvuMw9sZ8lhtXaHTkIKAr2Ap0GtWi5hclLVjGLlPmk1y4f7q1mubcqdZZ4k0djn//Z","aspectRatio":2,"src":"//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=1200&q=100","srcSet":"//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=300&h=150&q=100 300w,\n//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=600&h=300&q=100 600w,\n//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=1200&h=600&q=100 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}},"featuredImage":{"fluid":{"base64":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAACAAFB//EACUQAAEEAQMEAgMAAAAAAAAAAAECAwQRBQAHIQYSE2EUQRUx0f/EABYBAQEBAAAAAAAAAAAAAAAAAAQBAv/EABoRAQEAAgMAAAAAAAAAAAAAAAECAAMEEWH/2gAMAwEAAhEDEQA/AHNP3TjJd8LuHfAQhJLwksFIskVZXZ+qPvmv3rncje8zi6zM6QlMrK3EtqkS4QQ6AkqSbD5ruHA+75IA50ZMPlZpweRUZj5V4lGy6q7tPvWT1PlJiekJLolvh38hHHeHFd1fFc4u9D176YK9DF3pCk8XElI3ifjvuMw9sZ8lhtXaHTkIKAr2Ap0GtWi5hclLVjGLlPmk1y4f7q1mubcqdZZ4k0djn//Z","aspectRatio":2,"src":"//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=1200&q=100","srcSet":"//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=300&h=150&q=100 300w,\n//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=600&h=300&q=100 600w,\n//images.ctfassets.net/swk93j7qai6c/8QFyqkoeCLA2aIidUWhJ5/cdc90f13468603df2d87acdce21bd4dc/header-image-10.jpg?w=1200&h=600&q=100 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"dbbaa0a4-45f8-5276-baae-71360b2aca88"}}}